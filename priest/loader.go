package priest

import (
	"bytes"
	"fmt"
	"github.com/fsnotify/fsnotify"
	log "github.com/sirupsen/logrus"
	"os"
	"path"
	"path/filepath"
	"runtime"
	"strings"
)

func ScanDir(dir, moduleName, moduleDir string) ([]*Pkg, error) {
	packageList := make([]*Pkg, 0)
	pkg, err := scanDir(dir, moduleName, moduleDir)
	if err != nil {
		return nil, err
	}
	if pkg != nil {
		packageList = append(packageList, pkg)
	}
	children, err := scanChildrenDir(dir, moduleName, moduleDir)
	if err != nil {
		return nil, err
	}
	packageList = append(packageList, children...)
	return packageList, nil
}

func scanDir(dir, moduleName, moduleDir string) (*Pkg, error) {
	defer TimeStat("scanDir:" + dir)()
	dirs, err := os.ReadDir(dir)
	if err != nil {
		return nil, err
	}

	var pkg Pkg
	for i := range dirs {
		if !dirs[i].IsDir() {
			filename := path.Join(dir, dirs[i].Name())
			if strings.HasSuffix(filename, ".go") {
				rst, err := goFileParse(filename)
				if err != nil {
					return nil, err
				}
				if rst != nil {
					pkg.ID = rst.Path
					pkg.Name = rst.PkgName
					rel, err := filepath.Rel(moduleDir, dir)
					if err != nil {
						return nil, err
					}
					pkg.PkgPath = filepath.Join(moduleName, rel)
					pkg.FuncList = append(pkg.FuncList, rst.InjectNames...)
				}
			}
		}
	}
	if pkg.FuncList == nil {
		return nil, nil
	}
	return &pkg, nil
}

func scanChildrenDir(dir, moduleName, moduleDir string) ([]*Pkg, error) {
	packageList := make([]*Pkg, 0)

	dirs, err := os.ReadDir(dir)
	if err != nil {
		return nil, err
	}
	for i := range dirs {
		if dirs[i].IsDir() && dirs[i].Name() != ".git" {
			list, err := ScanDir(path.Join(dir, dirs[i].Name()), moduleName, moduleDir)
			if err != nil {
				return nil, err
			}
			packageList = append(packageList, list...)
		}
	}
	return packageList, nil
}

type Pkg struct {
	ID       string //包的绝对路径
	Name     string
	PkgPath  string
	FuncList []Fn
}

func (p *Pkg) generateFuncContent(isSelfModule bool) string {
	if len(p.FuncList) > 0 {
		strList := make([]string, 0)
		for i := range p.FuncList {
			fn := p.FuncList[i]
			name := p.Name
			if isSelfModule {
				name = ""
			} else {
				name = name + "."
			}
			strList = append(strList,
				fmt.Sprintf("    %s", fn.Gen(name)),
			)
		}
		return strings.Join(strList, "\n")
	}
	return ""
}

func normal(pkgPath string) string {
	if runtime.GOOS == "windows" {
		return strings.ReplaceAll(pkgPath, "\\", "/")
	}
	return pkgPath
}

func (p *Pkg) genImportContent() string {
	if path.Base(p.PkgPath) != p.Name {
		return fmt.Sprintf("    %s \"%s\"", p.Name, normal(p.PkgPath))
	} else {
		return fmt.Sprintf("    \"%s\"", normal(p.PkgPath))
	}
}

type autoload struct {
	scanDir      []string
	packageName  string
	functionName string
	outputFile   string

	moduleName string
	moduleDir  string

	pkgsMap map[string]*Pkg
}

func (loader *autoload) genFileContent(pkgs []*Pkg, funcName string, pkgName string) string {
	imports := make([]string, 0)
	funcContents := make([]string, 0)

	for i := range pkgs {
		pkg := pkgs[i]

		self := loader.inSelfModule(pkg)

		funcContents = append(funcContents, pkg.generateFuncContent(self))
		if len(funcContents) > 0 && !self {
			imports = append(imports, pkg.genImportContent())
		}
	}

	imports = append(imports, "    \"github.com/gone-io/gone\"")

	var b bytes.Buffer

	b.WriteString("// Code generated by gone; DO NOT EDIT.\n")
	b.WriteString(fmt.Sprintf("package %s\n", pkgName))
	b.WriteString("import (\n")
	b.WriteString(strings.Join(imports, "\n"))
	b.WriteString("\n)\n\n")

	b.WriteString(fmt.Sprintf("func %s(cemetery gone.Cemetery) error {\n", funcName))
	b.WriteString(strings.Join(funcContents, "\n"))
	b.WriteString("\n\treturn nil\n}\n")
	return b.String()
}

func (loader *autoload) generate(outputFile string) {
	l := len(loader.pkgsMap)
	packages := make([]*Pkg, 0, l)

	for _, v := range loader.pkgsMap {
		packages = append(packages, v)
	}

	content := loader.genFileContent(packages, loader.functionName, loader.packageName)
	err := os.WriteFile(outputFile, []byte(content), 0666)
	if err != nil {
		log.Error("write file error:", err)
	}
}

func (loader *autoload) fillModuleInfo() error {
	info, absPath, err := goModuleInfo(loader.scanDir[0])
	if err != nil {
		return err
	}
	loader.moduleName = info
	loader.moduleDir = absPath
	return nil
}

func (loader *autoload) firstGenerate() error {
	packages := make([]*Pkg, 0)
	for _, dir := range loader.scanDir {
		pkgList, err := ScanDir(dir, loader.moduleName, loader.moduleDir)
		if err != nil {
			return err
		}
		packages = append(packages, pkgList...)
	}

	loader.pkgsMap = make(map[string]*Pkg)
	for _, pkg := range packages {
		loader.pkgsMap[pkg.ID] = pkg
	}

	loader.generate(loader.outputFile)
	return nil
}

func (loader *autoload) reGenerate(dir string, filename string, op fsnotify.Op) {
	log.Infof("%v %s in %s", op, filename, dir)
	pkg, err := scanDir(dir, loader.moduleName, loader.moduleDir)
	if err != nil {
		log.Errorf("scan %s err:%v", dir, err)
		return
	}
	if pkg != nil {
		loader.pkgsMap[pkg.ID] = pkg
	} else {
		delete(loader.pkgsMap, dir)
	}
	loader.generate(loader.outputFile)
}

func (loader *autoload) inSelfModule(v *Pkg) bool {
	abs, _ := filepath.Abs(loader.outputFile)
	return filepath.Dir(abs) == v.ID
}
